class Goods:
    def __init__(self):
        print("__init__.Goods")


class MixinLog:
    def __init__(self):
        print("__init__.MixinLog")


class NoteBook(Goods, MixinLog):
    pass


# При множественном наследовании метод сначала будет искаться внутри пространства текущего класса, затем по порядку в
# родительских классах. Как только необходимый метод будет найден, то он вызовется и поиск прекратится.
# Инициализатор класса MixinLog не вызовется, хотя ожидается.
notebook = NoteBook()


class Goods:
    def __init__(self):
        # super(type, object-or-type) – обеспечивает доступ к оригиналам наследованных методов.
        # type – необязательный аргумент, тип, от которого начинается поиск объекта-посредника,
        # object-or-type – необязательный аргумент, тип или объект, определяет порядок разрешения метода для поиска.
        # Возвращаемое значение – объект-посредник, делегирующий вызовы методов родителю или собрату класса.
        # Такой вызов методов родительских классов называется делегированием, то есть управление передаётся кому-то
        # другому.
        super().__init__()
        print("__init__.Goods")


class MixinLog:
    def __init__(self):
        print("__init__.MixinLog")


class NoteBook(Goods, MixinLog):
    pass


print()
# Теперь вызовется два инициализатора.
notebook2 = NoteBook()
# Но как super().__init__() знает, что нужно вызывать инициализатор класса MixinLog?
# Всё дело в том, что цепочка вызовов родительских методов в python содержится в коллекции __mro__.
print("\n", NoteBook.__mro__)  # (<class '__main__.NoteBook'>, <class '__main__.Goods'>, <class '__main__.MixinLog'>, <class 'object'>)

# Порядок наследования очень важен.
# Если инициализатор не был определён в классе, то будет вызван инициализатор первого родительского класса.
# Поэтому лучше делать так, чтобы инициализаторы других родительских классов не принимали аргументов кроме self.
# Это позволит избежать ошибок и путаницы. Продумывать порядок наследования нужно исходя из этого.
